// SimplexNoise
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf - Stefan Gustavson

require RGB;
require Image2DRGB;

struct Gradient
{
  Float32 x, y, z, w;
};

function Gradient()
{
  this.x = 0;
  this.y = 0;
  this.z = 0;
  this.w = 0;
}

function Gradient(Float32 x, Float32 y, Float32 z)
{
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = 0;
}

function Gradient(Float32 x, Float32 y, Float32 z, Float32 w) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;
}

inline Integer fastfloor(Float32 x)
{
  Integer xi = Integer(x);
  return x<xi ? xi-1 : xi;
}

inline Float32 dot(Gradient g, Float32 x, Float32 y)
{
  return g.x*x + g.y*y;
}

inline Float32 dot(Gradient g, Float32 x, Float32 y, Float32 z)
{
  return g.x*x + g.y*y + g.z*z;
}

inline Float32 dot(Gradient g, Float32 x, Float32 y, Float32 z, Float32 w)
{
  return g.x*x + g.y*y + g.z*z + g.w*w;
}

struct SimplexNoise
{
  Gradient grad3[];
  Gradient grad4[];

  SInt16 perm[512];
  SInt16 permMod12[512];

  Float32 F2, G2, F3, G3, F4, G4;
};

inline SimplexNoise()
{
  this.init();
}

inline SimplexNoise.init()
{

  const Float32 g3[] = [
    1,1,0,-1,1,0,1,-1,0,-1,-1,0,
    1,0,1,-1,0,1,1,0,-1,-1,0,-1,
    0,1,1,0,-1,1,0,1,-1,0,-1,-1
    ];

  for(Index i=0; i<g3.size(); i+=3)
  {
    this.grad3.push(Gradient(g3[i], g3[i+1], g3[i+2]));
  }

  const Float32 g4[] = [
    0,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,
    0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,
    1,0,1,1,1,0,1,-1,1,0,-1,1,1,0,-1,-1,
    -1,0,1,1,-1,0,1,-1,-1,0,-1,1,-1,0,-1,-1,
    1,1,0,1,1,1,0,-1,1,-1,0,1,1,-1,0,-1,
    -1,1,0,1,-1,1,0,-1,-1,-1,0,1,-1,-1,0,-1,
    1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,
    -1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,0
    ];

  for(Index i=0; i<g4.size(); i+=4)
  {
    this.grad4.push(Gradient(g4[i], g4[i+1], g4[i+2], g4[i+3]));
  }

  const SInt16 p[] = [
    151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
    8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
    35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
    134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
    55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,
    18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
    250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
    189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
    172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
    228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
    107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
    ];

  for(Index i=0; i<512; i++)
  {
    this.perm[i] = p[i & 255];
    this.permMod12[i] = this.perm[i] % 12;
  }

  this.F2 = 0.5*(sqrt(3.0)-1.0);
  this.G2 = (3.0-sqrt(3.0))/6.0;
  this.F3 = 1.0/3.0;
  this.G3 = 1.0/6.0;
  this.F4 = (sqrt(5.0)-1.0)/4.0;
  this.G4 = (5.0-sqrt(5.0))/20.0;

}

inline Float32 SimplexNoise.noise2D(Float32 xin, Float32 yin)
{
    Float32 n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    Float32 s = (xin+yin)*this.F2; // Hairy factor for 2D
    Integer i = fastfloor(xin+s);
    Integer j = fastfloor(yin+s);
    Float32 t = (i+j)*this.G2;
    Float32 X0 = i-t; // Unskew the cell origin back to (x,y) space
    Float32 Y0 = j-t;
    Float32 x0 = xin-X0; // The x,y distances from the cell origin
    Float32 y0 = yin-Y0;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    Integer i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
    else {i1=0; j1=1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1)
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    Float32 x1 = x0 - i1 + this.G2; // Offsets for middle corner in (x,y) unskewed coords
    Float32 y1 = y0 - j1 + this.G2;
    Float32 x2 = x0 - 1.0 + 2.0 * this.G2; // Offsets for last corner in (x,y) unskewed coords
    Float32 y2 = y0 - 1.0 + 2.0 * this.G2;
    // Work out the hashed gradient indices of the three simplex corners
    Integer ii = i & 255;
    Integer jj = j & 255;
    Integer gi0 = this.permMod12[ii+this.perm[jj]];
    Integer gi1 = this.permMod12[ii+i1+this.perm[jj+j1]];
    Integer gi2 = this.permMod12[ii+1+this.perm[jj+1]];
    // Calculate the contribution from the three corners
    Float32 t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) n0 = 0.0;
    else {
      t0 *= t0;
      n0 = t0 * t0 * dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    Float32 t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) n1 = 0.0;
    else {
      t1 *= t1;
      n1 = t1 * t1 * dot(this.grad3[gi1], x1, y1);
    }
    Float32 t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) n2 = 0.0;
    else {
      t2 *= t2;
      n2 = t2 * t2 * dot(this.grad3[gi2], x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70.0 * (n0 + n1 + n2);
}

operator simplex<<<index>>>(
  in SimplexNoise noise,
  io Image2DRGB image,
  in Float32 scale
  )
{
  Index row = index / image.width;
  Index col = index % image.width;
  Float32 u = 0.0;
  Float32 v = 0.0;

  if (row>0)
  {
    u = Float32(row)/Float32(image.height);
    u *= scale;
  }
  if (col>0)
  {
    v = Float32(col)/Float32(image.width);
    v *= scale;
  }

  // get noise2d and rescale to 0-1
  Float32 value = (noise.noise2D(u, v) + 1.0)*0.5;

  Byte shade = Byte(value*256);
  image.setPixel(col, row, RGB(shade,shade,shade));

}

operator computePixels(
  Size resolution,
  Float32 scale,
  io Image2DRGB image)
{
  image.resize(resolution, resolution);

  SimplexNoise snoise();
  simplex<<<image.pixels.size()>>>(snoise, image, scale);
  image.incrementVersion();

  // Integer dim = resolution;
  // Float32 u[],v[],t[],o[];
  // u.resize(dim*dim);
  // v.resize(dim*dim);
  // t.resize(dim);

  // // generate sequence of numbers [0-1]
  // for (Index i=0; i<dim;i++)
  // {
  //   if(i==0)
  //   {
  //     t[i] = 0.0;
  //   }
  //   else
  //   {
  //     t[i] = i/Float32(dim);
  //   }
  // }

  // // generate samples in u,v
  // for (Index i=0; i<dim; i++)
  // {
  //   for (Index j=0; j<dim; j++)
  //   {
  //     u[i*dim+j] = t[i];
  //     v[i*dim+j] = t[j];
  //   }
  // }

}